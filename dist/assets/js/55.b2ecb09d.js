(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{359:function(v,_,t){"use strict";t.r(_);var s=t(3),S=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器渲染页面的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染页面的流程"}},[v._v("#")]),v._v(" 浏览器渲染页面的流程")]),v._v(" "),_("h2",{attrs:{id:"dom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[v._v("#")]),v._v(" DOM")]),v._v(" "),_("ol",[_("li",[v._v("一般先请求服务器得到HTML文件，不过一开始浏览器得到的是显示字节内容的HTML文件")]),v._v(" "),_("li",[v._v("把字节转化为字符")]),v._v(" "),_("li",[v._v("浏览器把字符转换为"),_("strong",[v._v("Token")]),v._v("，可以简单把Token理解为符号标签")]),v._v(" "),_("li",[v._v("把Token转换为节点对象")]),v._v(" "),_("li",[v._v("把节点对象连接在一起，形成"),_("strong",[v._v("文本对象模型")]),v._v("(Document Object Model, DOM)")])]),v._v(" "),_("blockquote",[_("p",[v._v("每个节点对象相连形成父子关系，如果之后要对某个节点对象进行操作，对于浏览器来说就非常友好了")])]),v._v(" "),_("h2",{attrs:{id:"cssom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cssom"}},[v._v("#")]),v._v(" CSSOM")]),v._v(" "),_("blockquote",[_("p",[v._v("浏览器遇到link标签，浏览器会向服务器发生请求，得到CSS文件，后面的流程和处理HTML文件非常相似")])]),v._v(" "),_("ol",[_("li",[v._v("一般先请求服务器得到CSS文件，不过一开始浏览器得到的是显示字节内容的HTML文件")]),v._v(" "),_("li",[v._v("把字节转化为字符")]),v._v(" "),_("li",[v._v("浏览器把字符转换为"),_("strong",[v._v("Token")]),v._v("，可以简单把Token理解为符号标签")]),v._v(" "),_("li",[v._v("把Token转换为节点对象")]),v._v(" "),_("li",[v._v("把节点对象连接在一起，形成"),_("strong",[v._v("CSS对象模型")]),v._v("(Cascading Style Sheets Object Model, CSSOM)")])]),v._v(" "),_("h2",{attrs:{id:"渲染树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染树"}},[v._v("#")]),v._v(" 渲染树")]),v._v(" "),_("p",[v._v("页面就是要根据渲染树的结构样式来进行的，但是DOM和CSSOM不是简单的进行结合就好了，因为渲染树上的节点是页面能够呈现的内容，也就是一些HTML标签和某些样式是不会被呈现出来的(如mate和link标签)，不呈现出来就不会被挂在渲染树上，渲染树的任务就是"),_("strong",[v._v("匹配DOM和CSSOM的节点，并且捕获可见内容")])]),v._v(" "),_("h2",{attrs:{id:"布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#布局"}},[v._v("#")]),v._v(" 布局")]),v._v(" "),_("p",[v._v("在渲染树构造完以后是不能被马上渲染的，还要布局，也就是获取渲染树的结构、节点位置和大小，而"),_("strong",[v._v("布局是依据盒子模型来进行的")]),v._v("，盒子在页面上排列和嵌套")]),v._v(" "),_("h2",{attrs:{id:"绘制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#绘制"}},[v._v("#")]),v._v(" 绘制")]),v._v(" "),_("p",[v._v("把渲染树以像素的形式绘制在页面上，这样我们的网页就呈现出来了")]),v._v(" "),_("h2",{attrs:{id:"提示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#提示"}},[v._v("#")]),v._v(" 提示")]),v._v(" "),_("p",[v._v("如果先返回并且解析完成JS文件也是会发生阻塞的，必须等到CSSOM构建完成了才能执行JS文件(因为渲染树需要DOM和CSSOM构建完成后才能构建)，而且JS是可以控制DOM和CSS样式的。"),_("strong",[v._v("CSSOM的构建是渲染中一个重要的阻塞因素")]),v._v("，但是DOM也会阻塞页面渲染，但是"),_("strong",[v._v("DOM可以部分解析，而且CSSOM不能部分解析")]),v._v("，但是解析CSS文件的时候浏览器依然可以解析JS文件，等CSSOM构建完成就可以执行JS的内容了")]),v._v(" "),_("p",[v._v("如果不等JS下载解析执行完以后再构建DOM，有可能导致网页的有些内容出现又消失，所以在解析HTML文件的时候，"),_("strong",[v._v("JS代码都会让HTML的解析停止下来")]),v._v("，虽然DOM是可以部分解析的，但是对于这个网页来说相当于"),_("strong",[v._v("阻塞看第一次渲染")]),v._v("，JS执行完之前什么内容都没有，执行完以后，也就是形成渲染树(构建DOM后)，进行布局，最后绘制")]),v._v(" "),_("blockquote",[_("p",[v._v("现代浏览器会先提前下载script，link，src等标签的资源，不会等解析到标签的时候才下载")])]),v._v(" "),_("p",[v._v("即：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("CSS不会阻塞DOM解析，但会阻塞DOM渲染")])]),v._v(" "),_("li",[_("p",[v._v("JS阻塞DOM解析，但浏览器会预先下载相关资源")])]),v._v(" "),_("li",[_("p",[v._v("浏览器遇到scirpt且没有defer或async属性的时，会触发页面渲染，如果前面CSS资源未加载完毕，浏览器会等待加载完成后执行脚本")])])]),v._v(" "),_("h2",{attrs:{id:"css和js引入位置说明"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css和js引入位置说明"}},[v._v("#")]),v._v(" CSS和JS引入位置说明")]),v._v(" "),_("ol",[_("li",[v._v("CSS资源尽量放在head部分")]),v._v(" "),_("li",[v._v("JS资源尽量放在body结束标签之前")]),v._v(" "),_("li",[v._v("CSS资源尽量优先于JS资源引入")])]),v._v(" "),_("h2",{attrs:{id:"引入位置解释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引入位置解释"}},[v._v("#")]),v._v(" 引入位置解释")]),v._v(" "),_("ol",[_("li",[v._v("因为CSS解析和DOM解析可以同时进行，所以CSS资源放在头部不会影响DOM解析，而且放在头部也会优先开始加载CSS样式，在渲染DOM的时候也已经知道了自己的样式，所以一次就可渲染成功，如果将CSS放在底部，那么会优先渲染DOM，而浏览器为了更好的用户体验，渲染引擎会尝试尽快在屏幕上显示内容，也就是说渲染引擎会边解析、边渲染、边布局显示，已尽快减少白屏时间，所以随着CSS规则树的构建，还需要对之前渲染树重新渲染，可能会导致回流和页面跳动。")]),v._v(" "),_("li",[v._v("JS放在body标签结束之前，首先可以确保能取到需要操作的DOM对象，也可缩短因JS阻塞。而造成的白屏时间，提升用户体验。因为如果把JS放在head部分，JS运行会阻塞DOM树和CSS树构建，导致白屏时间延长，影响用户体验。")]),v._v(" "),_("li",[v._v("因为JS在运行时，如果需要操作CSS，但该CSS还没有下载和构建，则首先会阻塞JS线程，然后开启新线程去下载解析构建CSS规则树，再执行JS代码")])])])}),[],!1,null,null,null);_.default=S.exports}}]);